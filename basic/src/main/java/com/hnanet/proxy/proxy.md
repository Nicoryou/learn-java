## JDK 动态代理

- JDK的动态代理的写法比较固定，需要先定义一个接口和接口的实现类，然后再定义一个实现了InvocationHandler接口的实现类。然后调用Proxy类的newInstance()方法即可。
```text
根据class文件，分析了JDK动态代理中两个比较常见的问题
1. JDK的动态代理要基于接口实现，而不能基于继承来实现
    $Proxy0类继承了Proxy类，同时实现了UserService接口
    因为Java中不支持多继承，而JDK的动态代理在创建代理对象时，默认让代理对象继承了Proxy类，所以JDK只能通过接口去实现动态代理。
2. 在JDK的动态代理中，在目标对象方法内部调用自己的另一个方法时，另一个方法在执行时，为什么没有经过代理对象
    在insert()方法中调用query()方法时，实际上调用的是this.query()，
    而此时this对象是UserServiceImpl，并不是$Proxy0这个代理对象，只有在调用代理对象的query()方法时，才会经过InvocationHandler.invoke()方法。
    在调用过程中，this的指向发生了变化。
    
    在目标对象的方法A内部调用目标对象的其他方法B，此时动态代理并不会对方法B进行增强。
    相信很多人曾经碰到过在Spring项目中，通过@Transactional来声明事务时，出现了事务不生效的情况，结合本文，现在相信你应该能明白这其中的问题了
    同样的案例还有@Async等案例，在同一个类的两个方法中开启异步，然后在方法内部进行互相调用，最终导致异步失效的问题。

    当 Spring 上下文中的一个实现了某个接口的 Bean 通过JDK 动态代理机制被代理时，代理类并不是继承了目标类，而是实现同样的接口。
    也正因为如此，如果一个 Bean 通过接口注入时，可以成功被注入。但如果是通过真正的类注入，那么 Spring 将无法找到匹配这个类的 Definition ——因为代理类并没有继承这个类。
```

- CGLIB
> CGLIB 就是一个字节码生成和转换的库！这倒是不难理解，它主要被AOP，测试，数据访问框架用来生成动态代理对象和拦截字段访问。

> cglib类代理的基本思想就是对被代理类生成一个新的类（proxy），该类是继承自被代理类的，并对被代理类方法执行前后执行一些操作，这些操作的通常就是一些回调操作，可以是MethodInterceptor，LazyLoader,CallbackFilter,其中MethodInterceptor是最常用的。
```text
    所有被Enhancer关联的对象默认都是实现Factory接口的，该接口提供了一组可以设置对象回调类型的方法，你可以通过调用setUseFactory(false)取消此特性！
    需要注意的是，cglib是无法代理final修饰的方法的，因为这是java语言规范决定的！
    MethodInterceptor是一个提供环绕通知的通用回调接口！Aop中有这样的术语，那就是前置通知，后置通知，环绕通知，非常好理解，就是一个在方法执行前的通知，一个方法执行后的通知，另外一个就是方法执行前后都通知。
  
```